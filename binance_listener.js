// binance_listener.js (Modified for @bookTicker, sending best bid as p, enhanced error handling)

const WebSocket = require('ws');

// --- Global Error Handlers ---
process.on('uncaughtException', (err, origin) => {
    console.error(`[Listener] PID: ${process.pid} --- FATAL: UNCAUGHT EXCEPTION`);
    console.error(err.stack || err);
    console.error(`[Listener] Exception origin: ${origin}`);
    console.error(`[Listener] PID: ${process.pid} --- Exiting due to uncaught exception...`);
    setTimeout(() => {
        if (internalWsClient && typeof internalWsClient.terminate === 'function') {
            try { internalWsClient.terminate(); } catch (e) { /* ignore */ }
        }
        if (binanceWsClient && typeof binanceWsClient.terminate === 'function') {
            try { binanceWsClient.terminate(); } catch (e) { /* ignore */ }
        }
        process.exit(1);
    }, 1000).unref();
});

process.on('unhandledRejection', (reason, promise) => {
    console.error(`[Listener] PID: ${process.pid} --- FATAL: UNHANDLED PROMISE REJECTION`);
    console.error('[Listener] Unhandled Rejection at:', promise);
    console.error('[Listener] Reason:', reason instanceof Error ? reason.stack : reason);
    console.error(`[Listener] PID: ${process.pid} --- Exiting due to unhandled promise rejection...`);
    setTimeout(() => {
        if (internalWsClient && typeof internalWsClient.terminate === 'function') {
            try { internalWsClient.terminate(); } catch (e) { /* ignore */ }
        }
        if (binanceWsClient && typeof binanceWsClient.terminate === 'function') {
            try { binanceWsClient.terminate(); } catch (e) { /* ignore */ }
        }
        process.exit(1);
    }, 1000).unref();
});

// --- Configuration ---
const binanceStreamUrl = 'wss://stream.binance.com:9443/ws/btcusdt@bookTicker'; // MODIFIED for @bookTicker
const internalReceiverUrl = 'ws://localhost:8082';
const RECONNECT_INTERVAL_MS = 5000;
const BINANCE_PING_INTERVAL_MS = 3 * 60 * 1000; // 3 minutes for Binance official stream
const PRICE_CHANGE_THRESHOLD = 1.2;

// --- State Variables ---
let binanceWsClient = null;
let internalWsClient = null;
let binancePingIntervalId = null;
let lastSentPrice = null; // Stores the numeric value of the last price sent

// --- Internal Receiver Connection ---
function connectToInternalReceiver() {
    if (internalWsClient && (internalWsClient.readyState === WebSocket.OPEN || internalWsClient.readyState === WebSocket.CONNECTING)) {
        console.log('[Listener] Internal receiver connection attempt skipped: already open or connecting.');
        return;
    }
    console.log(`[Listener] PID: ${process.pid} --- Connecting to internal receiver: ${internalReceiverUrl}`);
    internalWsClient = new WebSocket(internalReceiverUrl);

    internalWsClient.on('open', () => {
        console.log(`[Listener] PID: ${process.pid} --- Connected to internal receiver.`);
        lastSentPrice = null; // Reset on new connection to ensure fresh data
    });

    internalWsClient.on('error', (err) => {
        console.error(`[Listener] PID: ${process.pid} --- Internal receiver WebSocket error:`, err.message);
    });

    internalWsClient.on('close', (code, reason) => {
        const reasonStr = reason ? reason.toString() : 'N/A';
        console.log(`[Listener] PID: ${process.pid} --- Internal receiver closed. Code: ${code}, Reason: ${reasonStr}. Reconnecting in ${RECONNECT_INTERVAL_MS / 1000}s...`);
        internalWsClient = null;
        setTimeout(connectToInternalReceiver, RECONNECT_INTERVAL_MS);
    });
}

/**
 * Transforms a @bookTicker message string into the desired client format.
 * Desired format: { e: "trade", E: number, p: string (best bid price) } or null.
 */
function transformBookTickerData(messageString) {
    try {
        const data = JSON.parse(messageString);

        // A @bookTicker message should have 'b' (best bid price) as a string.
        if (data && typeof data.b === 'string') {
            return {
                e: "trade",       // Client expects this event type, as per original requirement
                E: Date.now(),    // Event time (generated by listener, as @bookTicker doesn't have 'E')
                p: data.b         // Best bid price
            };
        }
        // Silently ignore if not in expected format or missing best bid price,
        // the main handler can log this if needed.
        return null;
    } catch (error) {
        // JSON.parse failed or other error.
        // console.warn('[Listener] Error parsing or transforming @bookTicker message:', error.message); // Keep silent by default
        return null;
    }
}

// --- Binance Stream Connection ---
function connectToBinance() {
    if (binanceWsClient && (binanceWsClient.readyState === WebSocket.OPEN || binanceWsClient.readyState === WebSocket.CONNECTING)) {
        console.log('[Listener] Binance connection attempt skipped: already open or connecting.');
        return;
    }
    console.log(`[Listener] PID: ${process.pid} --- Connecting to Binance: ${binanceStreamUrl}`);
    binanceWsClient = new WebSocket(binanceStreamUrl);

    binanceWsClient.on('open', function open() {
        console.log(`[Listener] PID: ${process.pid} --- Connected to Binance stream (${binanceStreamUrl.split('/').pop()}).`); // MODIFIED log
        lastSentPrice = null;

        if (binancePingIntervalId) clearInterval(binancePingIntervalId);
        binancePingIntervalId = setInterval(() => {
            if (binanceWsClient && binanceWsClient.readyState === WebSocket.OPEN) {
                try {
                    binanceWsClient.ping(() => {});
                } catch (pingError) {
                    console.error(`[Listener] PID: ${process.pid} --- Error sending ping to Binance:`, pingError.message);
                }
            }
        }, BINANCE_PING_INTERVAL_MS);
    });

    binanceWsClient.on('message', function incoming(data) {
        try {
            const messageString = data.toString();
            const minimalData = transformBookTickerData(messageString); // MODIFIED to use new function

            if (minimalData) {
                const currentPrice = parseFloat(minimalData.p); // 'p' is now best bid price
                if (isNaN(currentPrice)) {
                    console.warn(`[Listener] PID: ${process.pid} --- Invalid price (best bid) in transformed @bookTicker data:`, minimalData.p);
                    return;
                }

                let shouldSendData = false;
                if (lastSentPrice === null) {
                    shouldSendData = true;
                } else {
                    const priceDifference = Math.abs(currentPrice - lastSentPrice);
                    if (priceDifference >= PRICE_CHANGE_THRESHOLD) {
                        shouldSendData = true;
                    }
                }

                if (shouldSendData) {
                    if (internalWsClient && internalWsClient.readyState === WebSocket.OPEN) {
                        let minimalJsonString;
                        try {
                            minimalJsonString = JSON.stringify(minimalData);
                        } catch (stringifyError) {
                            console.error(`[Listener] PID: ${process.pid} --- CRITICAL: Error stringifying minimal data:`, stringifyError.message, stringifyError.stack);
                            return;
                        }
                        
                        try {
                            internalWsClient.send(minimalJsonString);
                            lastSentPrice = currentPrice;
                            // console.log(`[Listener] Sent to internal: ${minimalJsonString}`);
                        } catch (sendError) {
                            console.error(`[Listener] PID: ${process.pid} --- Error sending data to internal receiver:`, sendError.message, sendError.stack);
                        }
                    } else {
                        // console.warn(`[Listener] PID: ${process.pid} --- Internal receiver not open. Qualified data NOT sent.`);
                    }
                }
            } else {
                // transformBookTickerData returned null. This means the message was not a valid @bookTicker JSON,
                // or it was JSON but didn't have the expected 'b' field.
                // Log if it's not a PONG message (which might be sent by Binance in some scenarios as JSON).
                if (messageString && !messageString.includes('"e":"pong"')) { 
                    // Note: Standard PONGs are frames, not JSON messages. However, checking for "e":"pong"
                    // is a safeguard if Binance ever sends such a JSON message on this stream.
                    console.warn(`[Listener] PID: ${process.pid} --- Received non-@bookTicker or unparseable message from Binance. Snippet:`, messageString.substring(0, 150));
                }
            }
        } catch (e) {
            console.error(`[Listener] PID: ${process.pid} --- CRITICAL ERROR in Binance message handler (outer catch):`, e.message, e.stack);
        }
    });

    binanceWsClient.on('pong', () => {
        // console.log('[Listener] Pong received from Binance.');
    });

    binanceWsClient.on('error', function error(err) {
        console.error(`[Listener] PID: ${process.pid} --- Binance WebSocket error:`, err.message);
    });

    binanceWsClient.on('close', function close(code, reason) {
        const reasonStr = reason ? reason.toString() : 'N/A';
        console.log(`[Listener] PID: ${process.pid} --- Binance WebSocket closed. Code: ${code}, Reason: ${reasonStr}. Reconnecting in ${RECONNECT_INTERVAL_MS / 1000}s...`);
        if (binancePingIntervalId) { clearInterval(binancePingIntervalId); binancePingIntervalId = null; }
        binanceWsClient = null;
        setTimeout(connectToBinance, RECONNECT_INTERVAL_MS);
    });
}

// --- Start the connections ---
// MODIFIED log message to reflect new stream and data meaning
console.log(`[Listener] PID: ${process.pid} --- Binance listener starting (subscribing to btcusdt@bookTicker, sending best bid as 'p' in 'trade' event format, Price Threshold: ${PRICE_CHANGE_THRESHOLD})`);
connectToBinance();
connectToInternalReceiver();
console.log(`[Listener] PID: ${process.pid} --- Initial connection attempts initiated.`);
